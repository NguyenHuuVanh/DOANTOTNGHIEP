require("dotenv").config();
const express = require("express");
const mysql = require("mysql");
const cors = require("cors");
const bcrypt = require("bcrypt");
const moment = require("moment");
const bodyParser = require("body-parser");
const cookieParser = require("cookie-parser");
const jwt = require("jsonwebtoken");
const nodemailer = require("nodemailer");
const saltRounds = parseInt(process.env.SALT_ROUNDS) || 10;
let verificationCodes = {}; // L∆∞u m√£ x√°c nh·∫≠n t·∫°m th·ªùi

const app = express();
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cors());
app.use(bodyParser.json());
app.use(cookieParser());
const data = require("./dataControl.json");

// Th√™m middleware cors
app.use(
  cors({
    origin: "*", // Ho·∫∑c ch·ªâ ƒë·ªãnh domain c·ªßa frontend, v√≠ d·ª•: 'https://example.com'
    methods: ["GET", "POST", "PUT", "DELETE"],
    allowedHeaders: ["Content-Type", "Authorization"],
  })
);

const dbConfig = {
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
};

const connection = mysql.createConnection(dbConfig);

connection.connect((err) => {
  if (err) {
    console.error("K·∫øt n·ªëi th·∫•t b·∫°i:", err.message);
    return;
  }
  console.log("K·∫øt n·ªëi th√†nh c√¥ng ƒë·∫øn MySQL!");
});

// reset password
const transporter = nodemailer.createTransport({
  host: "smtp.gmail.com",
  port: 465,
  secure: true,
  auth: {
    user: process.env.EMAIL_USER, // Thay b·∫±ng email c·ªßa b·∫°n
    pass: process.env.EMAIL_PASS, // Thay b·∫±ng m·∫≠t kh·∫©u ·ª©ng d·ª•ng c·ªßa b·∫°n
  },
});

// api node control
app.get("/node_control", (req, res) => {
  res.json({
    data,
  });
});

app.put("/node_control/:id", (req, res) => {
  const { id } = req.params;
  const relay = data.find((r) => r.id === parseInt(id));

  if (!relay) {
    return res.status(404).json({ message: "Relay kh√¥ng t·ªìn t·∫°i" });
  }

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i
  relay.status = relay.status === "ON" ? "OFF" : "ON";
  relay.time = new Date().toLocaleTimeString();
  relay.date = new Date().toISOString().split("T")[0];

  res.json(relay);
});

app.get("/node_data", (req, res) => {
  // Truy v·∫•n ƒë·ªÉ l·∫•y ng√†y m·ªõi nh·∫•t
  const latestDateQuery = "SELECT MAX(DATE(created_at)) AS latest_date FROM node_data";

  connection.query(latestDateQuery, (err, result) => {
    if (err) {
      console.error("L·ªói khi truy v·∫•n ng√†y m·ªõi nh·∫•t:", err.message);
      res.status(500).send({ error: "L·ªói server khi truy v·∫•n ng√†y m·ªõi nh·∫•t" });
      return;
    }

    const latestDate = result[0].latest_date;

    if (!latestDate) {
      res.status(404).send({ message: "Kh√¥ng c√≥ d·ªØ li·ªáu trong b·∫£ng" });
      return;
    }

    // Truy v·∫•n ƒë·ªÉ l·∫•y d·ªØ li·ªáu c·ªßa ng√†y m·ªõi nh·∫•t
    const query = "SELECT * FROM node_data WHERE DATE(created_at) = ?";
    connection.query(query, [latestDate], (err, data) => {
      const dataNodes = {
        node1: [],
        node2: [],
      };

      if (err) {
        console.error("L·ªói khi truy v·∫•n d·ªØ li·ªáu:", err.message);
        res.status(500).send({ error: "L·ªói server khi truy v·∫•n d·ªØ li·ªáu" });
        return;
      }

      // ƒê·ªãnh d·∫°ng l·∫°i tr∆∞·ªùng created_at
      const formattedResults = data.map((row) => ({
        ...row,
        created_at: moment(row.created_at).format("YYYY-MM-DD HH:mm:ss"),
      }));

      formattedResults.forEach((item) => {
        if (item.device_id === 1) {
          dataNodes.node1.push(item);
        } else if (item.device_id === 2) {
          dataNodes.node2.push(item);
        }
      });

      res.status(200).json(dataNodes); // Tr·∫£ v·ªÅ k·∫øt qu·∫£ d∆∞·ªõi d·∫°ng JSON
    });
  });
});

app.post("/register", (req, res) => {
  const { username, firstname, lastname, email, password, role } = req.body;

  if (!username || !email || !password) {
    return res.status(400).json({ message: "Please enter complete information" });
  }

  const checkQuery = "SELECT username, email FROM users WHERE username = ? OR email = ?";
  connection.query(checkQuery, [username, email], (err, result) => {
    if (err) {
      return res.status(500).json({ message: "Server error while checking data", error: err });
    }

    let errors = {};
    if (result.some((user) => user.username === username)) {
      errors.username = "Username already exists!";
    }
    if (result.some((user) => user.email === email)) {
      errors.email = "Email already exists!";
    }

    if (Object.keys(errors).length > 0) {
      return res.status(400).json({ errors });
    }

    bcrypt.hash(password, saltRounds, (err, hash) => {
      if (err) return res.status(500).json({ message: "Password encryption error" });

      const insertQuery =
        "INSERT INTO users (`username`, `firstname`, `lastname`, `email`, `password`, `role`) VALUES (?, ?, ?, ?, ?, ?)";
      connection.query(insertQuery, [username, firstname, lastname, email, hash, role || "user"], (err, result) => {
        if (err) {
          return res.status(500).json({ message: "Server error when adding user" });
        }
        res.status(201).json({ message: "Registered successfully", userId: result.insertId });
      });
    });
  });
});

app.post("/login", (req, res) => {
  const query = "SELECT * FROM users WHERE email = ?";
  const { email, password } = req.body;

  if (!email || !password) {
    return res.status(400).json({ message: "Please enter email and password" });
  }

  connection.query(query, [email], (err, data) => {
    if (err) {
      return res.status(500).json({ message: "Database query error", error: err });
    }

    if (data.length === 0) {
      return res.status(404).json({ message: "Account does not exist" });
    }

    const user = data[0];

    bcrypt.compare(password, user.password, (err, result) => {
      if (err) {
        return res.status(500).json({ message: "Error when comparing passwords", error: err });
      }
      if (!result) {
        return res.status(401).json({ message: "Wrong password" });
      }

      if (!process.env.JWT_SECRET) {
        console.error("Error: JWT_SECRET is not defined in .env");
        return res.status(500).json({ message: "Server Error: JWT_SECRET is not configured" });
      }

      const expiresIn = req.body.rememberMe ? "7d" : "1h";
      const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET, { expiresIn });

      // ƒê·ªãnh d·∫°ng l·∫°i birthday tr∆∞·ªõc khi tr·∫£ v·ªÅ
      const formattedBirthday = user.birthday ? moment(user.birthday).format("DD/MM/YYYY") : "";

      res.json({
        message: "Log in successfully",
        token,
        user: {
          id: user.id,
          username: user.username,
          firstname: user.firstname,
          lastname: user.lastname,
          email: user.email,
          language: user.language,
          birthday: formattedBirthday,
          phonenumber: user.phonenumber,
          country: user.country,
          address: user.address,
          message: user.message,
          role: user.role,
        },
      });
    });
  });
});

app.post("/check-email", async (req, res) => {
  const { email } = req.body;
  const query = "SELECT * FROM users WHERE email = ?";

  connection.query(query, [email], (err, result) => {
    if (err) {
      return res.status(500).json({ success: false, message: "L·ªói k·∫øt n·ªëi c∆° s·ªü d·ªØ li·ªáu" });
    }
    if (result.length === 0) {
      return res.json({ exists: false });
    }
    res.json({ exists: true });
  });
});

// send-reset-code endpoint
app.post("/send-reset-code", async (req, res) => {
  const { email } = req.body;
  if (!email) return res.status(400).json({ success: false, message: "Email is required" });

  const code = Math.floor(100000 + Math.random() * 900000).toString(); // M√£ 6 ch·ªØ s·ªë
  verificationCodes[email] = { code, expiresAt: Date.now() + 15 * 60 * 1000 }; // H·∫øt h·∫°n sau 15 ph√∫t

  const mailOptions = {
    from: "iotdevicemanager.id.vn",
    to: email,
    subject: "üîë Password Reset Request",
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; padding: 20px; background: #f4f4f4; border-radius: 8px;">
        <h2 style="color: #333; text-align: center;">üîê Reset Your Password</h2>
        <p style="font-size: 16px; color: #555;">You requested a password reset. Use the verification code below:</p>
        <div style="font-size: 24px; font-weight: bold; text-align: center; padding: 10px; background: #fff; border-radius: 4px; border: 1px solid #ddd;">
          ${code}
        </div>
        <p style="font-size: 14px; color: #777; text-align: center;">This code will expire in <strong>15 minutes</strong>.</p>
        <p style="font-size: 14px; color: #777; text-align: center;">If you didn't request this, please ignore this email.</p>
        <p style="text-align: center; font-size: 12px; color: #999;">&copy; 2025 Your Company. All rights reserved.</p>
      </div>
    `,
  };

  try {
    await transporter.sendMail(mailOptions);
    res.json({ success: true, message: "Verification code sent successfully!" });
  } catch (error) {
    res.status(500).json({ success: false, message: "Failed to send email" });
  }
});

app.post("/verify-reset-code", (req, res) => {
  const { email, code } = req.body;
  if (!email || !code) return res.status(400).json({ success: false, message: "Email and code are required" });

  const data = verificationCodes[email];
  if (!data || data.code !== code || Date.now() > data.expiresAt) {
    return res.status(400).json({ success: false, message: "Invalid or expired code" });
  }

  delete verificationCodes[email]; // X√≥a m√£ sau khi x√°c minh th√†nh c√¥ng
  res.json({ success: true, message: "Verification successful!" });
});

// üîë C·∫≠p nh·∫≠t m·∫≠t kh·∫©u m·ªõi v√†o MySQL
app.post("/reset-password", async (req, res) => {
  const { email, newPassword } = req.body;
  if (!email || !newPassword) {
    return res.status(400).json({ success: false, message: "Email v√† m·∫≠t kh·∫©u m·ªõi l√† b·∫Øt bu·ªôc" });
  }

  const hashedPassword = await bcrypt.hash(newPassword, saltRounds); // M√£ h√≥a m·∫≠t kh·∫©u tr∆∞·ªõc khi l∆∞u

  const query = "UPDATE users SET password = ? WHERE email = ?";
  connection.query(query, [hashedPassword, email], (err, result) => {
    if (err) {
      return res.status(500).json({ success: false, message: "L·ªói c·∫≠p nh·∫≠t m·∫≠t kh·∫©u" });
    }
    res.json({ success: true, message: "M·∫≠t kh·∫©u ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng!" });
  });
});

// thay ƒë·ªïi m·∫≠t kh·∫©u
app.post("/change-password", (req, res) => {
  const { currentPassword, newPassword, confirmPassword } = req.body;
  const token = req.headers.authorization?.split(" ")[1]; // L·∫•y token t·ª´ header (Bearer token)

  // Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng nh·∫≠p ch∆∞a
  if (!token) {
    return res.status(401).json({ success: false, message: "B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p" });
  }

  try {
    // X√°c th·ª±c token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const userId = decoded.userId;

    // Ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
    if (!currentPassword || !newPassword || !confirmPassword) {
      return res.status(400).json({ success: false, message: "Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin" });
    }

    if (newPassword !== confirmPassword) {
      return res.status(400).json({ success: false, message: "M·∫≠t kh·∫©u m·ªõi v√† x√°c nh·∫≠n m·∫≠t kh·∫©u kh√¥ng kh·ªõp" });
    }

    if (newPassword.length < 6) {
      return res.status(400).json({ success: false, message: "M·∫≠t kh·∫©u m·ªõi ph·∫£i c√≥ √≠t nh·∫•t 6 k√Ω t·ª±" });
    }

    // L·∫•y m·∫≠t kh·∫©u hi·ªán t·∫°i t·ª´ c∆° s·ªü d·ªØ li·ªáu
    const query = "SELECT password FROM users WHERE id = ?";
    connection.query(query, [userId], (err, result) => {
      if (err) {
        return res.status(500).json({ success: false, message: "L·ªói k·∫øt n·ªëi c∆° s·ªü d·ªØ li·ªáu" });
      }
      if (result.length === 0) {
        return res.status(404).json({ success: false, message: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i" });
      }

      const hashedPassword = result[0].password;

      // So s√°nh m·∫≠t kh·∫©u hi·ªán t·∫°i
      bcrypt.compare(currentPassword, hashedPassword, (err, isMatch) => {
        if (err) {
          return res.status(500).json({ success: false, message: "L·ªói khi so s√°nh m·∫≠t kh·∫©u" });
        }
        if (!isMatch) {
          return res.status(401).json({ success: false, message: "M·∫≠t kh·∫©u hi·ªán t·∫°i kh√¥ng ƒë√∫ng" });
        }

        // M√£ h√≥a m·∫≠t kh·∫©u m·ªõi
        bcrypt.hash(newPassword, saltRounds, (err, hash) => {
          if (err) {
            return res.status(500).json({ success: false, message: "L·ªói khi m√£ h√≥a m·∫≠t kh·∫©u" });
          }

          // C·∫≠p nh·∫≠t m·∫≠t kh·∫©u m·ªõi v√†o c∆° s·ªü d·ªØ li·ªáu
          const updateQuery = "UPDATE users SET password = ? WHERE id = ?";
          connection.query(updateQuery, [hash, userId], (err) => {
            if (err) {
              return res.status(500).json({ success: false, message: "L·ªói khi c·∫≠p nh·∫≠t m·∫≠t kh·∫©u" });
            }
            res.json({ success: true, message: "ƒê·ªïi m·∫≠t kh·∫©u th√†nh c√¥ng" });
          });
        });
      });
    });
  } catch (error) {
    console.error("JWT Error:", error.message);
    return res.status(401).json({ success: false, message: "Token kh√¥ng h·ª£p l·ªá" });
  }
});

app.put("/update-user", (req, res) => {
  const { id, username, firstname, lastname, language, birthday, phonenumber, country, address, message } = req.body;

  if (!id) {
    return res.status(400).json({ success: false, message: "User ID is required" });
  }

  // Ki·ªÉm tra ƒë·ªãnh d·∫°ng ng√†y sinh
  try {
    const parsedDate = new Date(birthday);
    if (isNaN(parsedDate.getTime())) {
      throw new Error("Invalid date");
    }
  } catch (error) {
    return res.status(400).json({
      success: false,
      message: "ƒê·ªãnh d·∫°ng ng√†y sinh kh√¥ng h·ª£p l·ªá (YYYY-MM-DD)",
    });
  }

  const sql = `
    UPDATE users 
    SET 
      username = ?,
      firstname = ?,
      lastname = ?,
      language = ?, 
      birthday = ?, 
      phonenumber = ?, 
      country = ?, 
      address = ?, 
      message = ?
    WHERE id = ?
  `;

  const values = [username, firstname, lastname, language, birthday, phonenumber, country, address, message, id];

  connection.query(sql, values, (err, result) => {
    if (err) {
      console.error("‚ùå L·ªói c·∫≠p nh·∫≠t user:", err);
      return res.status(500).json({ success: false, message: "L·ªói server khi c·∫≠p nh·∫≠t user" });
    }

    if (result.affectedRows === 0) {
      return res.status(404).json({ success: false, message: "Kh√¥ng t√¨m th·∫•y user ƒë·ªÉ c·∫≠p nh·∫≠t" });
    }

    // Query l·∫°i user t·ª´ database ƒë·ªÉ l·∫•y d·ªØ li·ªáu ch√≠nh x√°c
    const getSql = "SELECT * FROM users WHERE id = ?";
    connection.query(getSql, [id], (err, users) => {
      if (err || users.length === 0) {
        return res.status(500).json({ success: false, message: "L·ªói khi l·∫•y th√¥ng tin user" });
      }

      const user = users[0];

      // ƒê·ªãnh d·∫°ng l·∫°i birthday t·ª´ database
      const formattedBirthday = user.birthday ? moment(user.birthday).format("DD/MM/YYYY") : "";

      // Tr·∫£ v·ªÅ user m·ªõi sau khi c·∫≠p nh·∫≠t
      const updatedUser = {
        id: user.id,
        username: user.username,
        firstname: user.firstname,
        lastname: user.lastname,
        email: user.email,
        language: user.language,
        birthday: formattedBirthday,
        phonenumber: user.phonenumber,
        country: user.country,
        address: user.address,
        message: user.message,
      };
      return res.status(200).json({ success: true, message: "C·∫≠p nh·∫≠t th√†nh c√¥ng!", updatedUser });
    });
  });
});

app.get("/user/:id", (req, res) => {
  const userId = req.params.id;
  const query = "SELECT * FROM users WHERE id = ?";
  connection.query(query, [userId], (err, result) => {
    if (err) {
      return res.status(500).json({ success: false, message: "L·ªói khi l·∫•y th√¥ng tin ng∆∞·ªùi d√πng" });
    }
    if (result.length === 0) {
      return res.status(404).json({ success: false, message: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i" });
    }
    const user = result[0];
    const formattedBirthday = user.birthday ? moment(user.birthday).format("DD/MM/YYYY") : "";
    res.json({
      success: true,
      user: {
        id: user.id,
        username: user.username,
        firstname: user.firstname,
        lastname: user.lastname,
        email: user.email,
        language: user.language,
        birthday: formattedBirthday,
        phonenumber: user.phonenumber,
        country: user.country,
        address: user.address,
        message: user.message,
        role: user.role,
      },
    });
  });
});

// Backend route
app.get("/validate-token", (req, res) => {
  const token = req.headers.authorization?.split(" ")[1];

  if (!token) return res.json({ valid: false });

  try {
    jwt.verify(token, process.env.JWT_SECRET);
    res.json({ valid: true });
  } catch (error) {
    res.json({ valid: false });
  }
});

app.delete("/delete-user/:id", async (req, res) => {
  const userId = req.params.id;
  try {
    const result = await connection.query("DELETE FROM users WHERE id = ?", [userId]);
    if (result.affectedRows === 0) {
      return res.status(404).json({ message: "User not found" });
    }
    res.status(200).json({ message: "User deleted successfully" });
  } catch (error) {
    console.error("Error deleting user:", error);
    res.status(500).json({ message: "Database error", error });
  }
});

// Endpoint ƒë·ªÉ l∆∞u l·ªãch s·ª≠ command
app.post("/node_actions", async (req, res) => {
  const { device_id, command, status } = req.body;
  try {
    const result = await connection.query("INSERT INTO node_actions (device_id, command, status) VALUES (?, ?, ?)", [
      device_id,
      command,
      status || "Pending",
    ]);
    res.status(201).json({
      message: "L·ªãch s·ª≠ command ƒë√£ ƒë∆∞·ª£c l∆∞u",
      id: result.insertId,
    });
  } catch (error) {
    console.error("L·ªói khi l∆∞u l·ªãch s·ª≠ command:", error);
    res.status(500).json({ message: "L·ªói c∆° s·ªü d·ªØ li·ªáu", error });
  }
});

app.post("/contact", async (req, res) => {
  try {
    const { first_name, last_name, email, message } = req.body;

    // L∆∞u v√†o CSDL
    const [result] = await connection.query(
      "INSERT INTO contacts (first_name, last_name, email, message) VALUES (?, ?, ?, ?)",
      [first_name, last_name, email, message]
    );

    // G·ª≠i email
    await sendContactEmail({ first_name, last_name, email, message });

    res.status(201).json({
      success: true,
      message: "Message sent successfully!",
    });
  } catch (error) {
    console.error("Error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error",
    });
  }
});

const PORT = process.env.PORT;

app.listen(PORT || 3001, () => {
  console.log("Server is running on http:localhost:3001");
});
